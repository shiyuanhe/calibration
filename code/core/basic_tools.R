## create C++ object
create_CalibrationObj = function(problemIndex, thetaIndex, linkIndex,
                                 numComp = 1, 
                                 emuData = NULL, betaOpt = NULL,
                                 linkLowerB = NULL, linkUpperB = NULL){
    if(numComp == 1){
        calObj = new(calModel, problemIndex, 
                     thetaIndex, linkIndex, numComp)
    }else{
        calObj = new(calModelMulti, problemIndex, 
                     thetaIndex, linkIndex, numComp)
    }
    if(!is.null(emuData) && !is.null(betaOpt)){
        calObj$GP_setData(emuData$y, emuData$x)
        calObj$GP_setBeta(betaOpt)
    }
    if(!is.null(linkLowerB) && !is.null(linkUpperB)){
        calObj$set_linkBound(linkLowerB, linkUpperB)
    }
    return(calObj)
}


## Optimize once with initial value gammaInit
optimize_CalModelOnce = function(gammaInit, calObj){
    result = optim(gammaInit, fn = calObj$objFun, 
                   gr = calObj$gradFun, 
                   method = "BFGS",
                   control = list(maxit = 100))
    optGamma = result$par
    return(optGamma)
}

## Optimize multiple times (nTry)
## Init values are generated by function getInit
## nSample: sample size
optimize_CalModel = function(getInit, calObj, 
                             nSample, nTry,
                             TrueSeqX, thetaLower, thetaUpper){
    optValue = 1e10
    for(i in 1:nTry){
        gammaInit = getInit(nSample)
        try({
            result = optim(gammaInit, fn = calObj$objFun, 
                           gr = calObj$gradFun, 
                           method = "BFGS",
                           control = list(maxit = 200))
            yHat = calObj$predict_y(result$par, TrueSeqX, FALSE)
            ## Make sure the fitted theta is in the proper range
            checkRange = sum(yHat[,3] < thetaLower | 
                                 yHat[,3] > thetaUpper) /
                length(TrueSeqX)
            if(result$value < optValue && checkRange < 0.5){
                optValue = result$value
                optGamma = result$par
            }
        })
    }
    return(optGamma)
}



## Select tuning parameter lambda
## from 10-fold cross validation
selectLambdaGCV = function(calObjCC, lambdaSeq, nSample,
                        getInitGamma,
                        TrueSeqX, linkLowerB, linkUpperB,
                        plotcv = FALSE, nTry = 150){

        GCVSeq = rep(0, length(lambdaSeq))
        gammaOpt = NULL
        GCVOpt = 1e10
        sigmaHat = NULL
        lambdaOpt = NULL
        for(lambdaJ in 1:length(lambdaSeq)){
            calObjCC$setLambda(lambdaSeq[lambdaJ])
            if(lambdaJ == 1){
                gammaHat = optimize_CalModel(getInitGamma, calObjCC,
                                             nSample,
                                             TrueSeqX, linkLowerB,
                                             linkUpperB,
                                             nTry = 100)
            }else{
                gammaHat = optimize_CalModelOnce(gammaHat, calObjCC)
            }
            #yHat = calObjCC$predict_y(gammaOpt, TrueSeqX, TRUE)
            GCVSeq[lambdaJ] = calObjCC$compute_GCV(gammaHat)
            if(GCVSeq[lambdaJ] < GCVOpt){
                gammaOpt = gammaHat
                GCVOpt = GCVSeq[lambdaJ]
                sigmaHat = calObjCC$compute_Sigma(gammaHat)
                lambdaOpt = lambdaSeq[lambdaJ]
            }
        }

    # if plotcv
    if(plotcv){
        plot(log(lambdaSeq), GCVSeq)
    }
    return(list(gammaOpt = gammaOpt, 
                GCVOpt = GCVOpt, 
                sigmaHat = sigmaHat,
                lambdaOpt = lambdaOpt))
}

#